// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package sqlc

import (
	"context"
)

const addOption = `-- name: AddOption :one
INSERT OR REPLACE INTO
   options (option_name, description, option_type, option_from, default_value, example)
VALUES (?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at, option_name, description, option_type, option_from, default_value, example
`

type AddOptionParams struct {
	OptionName   string
	Description  string
	OptionType   string
	OptionFrom   string
	DefaultValue string
	Example      string
}

func (q *Queries) AddOption(ctx context.Context, arg AddOptionParams) (Option, error) {
	row := q.db.QueryRowContext(ctx, addOption,
		arg.OptionName,
		arg.Description,
		arg.OptionType,
		arg.OptionFrom,
		arg.DefaultValue,
		arg.Example,
	)
	var i Option
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.OptionName,
		&i.Description,
		&i.OptionType,
		&i.OptionFrom,
		&i.DefaultValue,
		&i.Example,
	)
	return i, err
}

const addSource = `-- name: AddSource :one
INSERT INTO sources (url) VALUES (?) ON CONFLICT(url) DO UPDATE SET url = excluded.url RETURNING id, created_at, updated_at, url
`

func (q *Queries) AddSource(ctx context.Context, url string) (Source, error) {
	row := q.db.QueryRowContext(ctx, addSource, url)
	var i Source
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Url,
	)
	return i, err
}

const addSourceOption = `-- name: AddSourceOption :one
INSERT INTO source_options (source_id, option_id) VALUES (?, ?) RETURNING source_id, option_id, created_at, updated_at
`

type AddSourceOptionParams struct {
	SourceID int64
	OptionID int64
}

func (q *Queries) AddSourceOption(ctx context.Context, arg AddSourceOptionParams) (SourceOption, error) {
	row := q.db.QueryRowContext(ctx, addSourceOption, arg.SourceID, arg.OptionID)
	var i SourceOption
	err := row.Scan(
		&i.SourceID,
		&i.OptionID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findOptions = `-- name: FindOptions :many
SELECT
    o.id,
    o.option_name,
    o.description,
    o.option_type,
    o.default_value,
    o.example,
    o.option_from,
    IFNULL(GROUP_CONCAT(s.url), '') AS source_list
FROM
    options o
LEFT JOIN
    source_options so ON o.id = so.option_id
LEFT JOIN
    sources s ON so.source_id = s.id
WHERE
    o.id IN (
        SELECT option_id FROM options_fts WHERE options_fts.option_name MATCH ?
    )
GROUP BY
    o.id
LIMIT
    ?
`

type FindOptionsParams struct {
	OptionName string
	Limit      int64
}

type FindOptionsRow struct {
	ID           int64
	OptionName   string
	Description  string
	OptionType   string
	DefaultValue string
	Example      string
	OptionFrom   string
	SourceList   interface{}
}

func (q *Queries) FindOptions(ctx context.Context, arg FindOptionsParams) ([]FindOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, findOptions, arg.OptionName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindOptionsRow
	for rows.Next() {
		var i FindOptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionName,
			&i.Description,
			&i.OptionType,
			&i.DefaultValue,
			&i.Example,
			&i.OptionFrom,
			&i.SourceList,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOptions = `-- name: GetAllOptions :many
SELECT
    o.id,
    o.option_name,
    o.description,
    o.option_type,
    o.default_value,
    o.example,
    o.option_from,
    IFNULL(GROUP_CONCAT(s.url), '') AS source_list
FROM
    options o
LEFT JOIN
    source_options so ON o.id = so.option_id
LEFT JOIN
    sources s ON so.source_id = s.id
GROUP BY
    o.id
`

type GetAllOptionsRow struct {
	ID           int64
	OptionName   string
	Description  string
	OptionType   string
	DefaultValue string
	Example      string
	OptionFrom   string
	SourceList   interface{}
}

func (q *Queries) GetAllOptions(ctx context.Context) ([]GetAllOptionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllOptions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOptionsRow
	for rows.Next() {
		var i GetAllOptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.OptionName,
			&i.Description,
			&i.OptionType,
			&i.DefaultValue,
			&i.Example,
			&i.OptionFrom,
			&i.SourceList,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOptionCount = `-- name: GetOptionCount :one
SELECT COUNT(*) FROM options
`

func (q *Queries) GetOptionCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOptionCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}
